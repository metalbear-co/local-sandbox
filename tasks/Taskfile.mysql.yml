version: '3'

vars:
  ROOT_DIR:
    sh: cd .. && pwd
  NAMESPACE: '{{.NAMESPACE | default "test-mirrord"}}'
  MODULAR_TESTS_DIR: '{{.ROOT_DIR}}/k8s/mysql/modular-tests'
  COMPLETE_TESTS_DIR: '{{.ROOT_DIR}}/k8s/mysql/complete-tests'
  MYSQL_COMPLETE_FILE: '{{.COMPLETE_TESTS_DIR}}/mysql-test.yaml'
  MARIADB_COMPLETE_FILE: '{{.COMPLETE_TESTS_DIR}}/mariadb-test.yaml'
  MYSQL_ROOT_PASSWORD: 'mysql-branch-pod-root-password'
  SOURCE_DB_PASSWORD: 'examplepassword'
  
  # Mirrord binary path (customize for your setup)
  MIRRORD_BIN: '{{.MIRRORD_BIN | default "/Users/test/Projects/test/metalbear/work/mirrord/target/aarch64-apple-darwin/debug/mirrord"}}'

tasks:
  test:modular:
    desc: "Run modular MySQL test (component-based structure)"
    cmds:
      - task: deploy:modular:all
      - task: verify:all
  
  test:modular:quick:
    desc: "Quick modular test - refresh MySQL data and verify (no cluster rebuild)"
    cmds:
      - task: refresh:modular
      - task: verify:all

  test:modular:race-condition:
    desc: "Test for race condition (modular) - deploys a branch and immediately tries to connect"
    cmds:
      - task: deploy:modular:base
      - echo "Deploying single test scenario to check for race condition..."
      - task: deploy:modular:scenario
        vars: {SCENARIO: env-val}
      - echo "Testing immediate connection after Ready status..."
      - |
        echo "Waiting for branch to be ready..."
        kubectl wait --for=jsonpath='{.status.phase}'=Ready mysqlbranchdatabase/mysql-test-branch-env-val -n {{.NAMESPACE}} --timeout=180s || true
        echo "Attempting to connect immediately after Ready status..."
        POD=$(kubectl get pods -n {{.NAMESPACE}} -l db-owner-name=mysql-test-branch-env-val --no-headers -o custom-columns=":metadata.name" | head -1)
        BRANCH_ID=$(kubectl get mysqlbranchdatabases -n {{.NAMESPACE}} mysql-test-branch-env-val -o jsonpath='{.spec.id}')
        if kubectl exec -n {{.NAMESPACE}} "$POD" -- mysql -uroot -p{{.MYSQL_ROOT_PASSWORD}} user -e "SELECT 1" >/dev/null 2>&1; then
          echo "Connection successful immediately after Ready"
        else
          echo "✗ Connection failed - possible race condition"
        fi
      - echo ""
      - echo "Race condition test completed!"

  
  deploy:modular:all:
    desc: "Deploy all modular test scenarios (base + all scenarios)"
    cmds:
      - task: _patch-operator
      - task: deploy:modular:base
      - task: deploy:modular:scenarios
      - task: _wait-for-databases
  
  deploy:modular:base:
    desc: "Deploy modular base resources (source database only)"
    cmds:
      - echo "Deploying source database..."
      - kubectl create namespace {{.NAMESPACE}} --dry-run=client -o yaml | kubectl apply -f -
      - kubectl apply -k {{.MODULAR_TESTS_DIR}}/base
      - task: _wait-source-db
  
  deploy:modular:scenarios:
    desc: "Deploy all modular test scenarios"
    cmds:
      - echo "Deploying test scenarios..."
      - task: deploy:modular:scenario
        vars: {SCENARIO: env-val}
      - task: deploy:modular:scenario
        vars: {SCENARIO: secret-ref}
      - task: deploy:modular:scenario
        vars: {SCENARIO: echo}
  
  deploy:modular:scenario:
    desc: "Deploy a specific modular test scenario"
    internal: true
    vars:
      SCENARIO: '{{.SCENARIO}}'
    cmds:
      - kubectl apply -k {{.MODULAR_TESTS_DIR}}/scenarios/{{.SCENARIO}}

  test:modular:env-val:
    desc: "Test modular env variable scenario only"
    cmds:
      - task: deploy:modular:base
      - task: deploy:modular:scenario
        vars: {SCENARIO: env-val}
      - sleep 15
      - task: verify:scenario
        vars: {SCENARIO: env-val, EXPECTED_USERS: 2, EXPECTED_ORDERS: 4}
  
  test:modular:secret-ref:
    desc: "Test modular secret reference scenario only"
    cmds:
      - task: deploy:modular:base
      - task: deploy:modular:scenario
        vars: {SCENARIO: secret-ref}
      - sleep 15
      - task: verify:scenario
        vars: {SCENARIO: secret-ref, EXPECTED_USERS: 1, EXPECTED_ORDERS: 4}

  verify:all:
    desc: "Verify all test results"
    cmds:
      - echo ""
      - task: verify:source
      - echo ""
      - task: verify:scenario
        vars: {SCENARIO: env-val, EXPECTED_USERS: 2, EXPECTED_ORDERS: 4, MODE: "full copy"}
      - echo ""
      - task: verify:scenario
        vars: {SCENARIO: secret-ref, EXPECTED_USERS: 1, EXPECTED_ORDERS: 4, MODE: "filtered (id>1)"}
      - echo ""
      - echo "Tip - Run 'task mysql:branches' to see branch status"
      - echo ""
  
  verify:source:
    desc: "Verify source database"
    cmds:
      - echo "Source Database (mysql-test)"
      - task: _query-source
        vars: 
          QUERY: "SELECT 'users' as tbl, COUNT(*) as cnt FROM users UNION SELECT 'orders', COUNT(*) FROM orders"
  
  verify:scenario:
    desc: "Verify a specific test scenario"
    internal: true
    vars:
      SCENARIO: '{{.SCENARIO}}'
      MODE: '{{.MODE | default ""}}'
      EXPECTED_USERS: '{{.EXPECTED_USERS | default "?"}}'
      EXPECTED_ORDERS: '{{.EXPECTED_ORDERS | default "?"}}'
    cmds:
      - |
        echo "Branch: {{.SCENARIO}} ({{.MODE}})"
        POD=$(kubectl get pods -n {{.NAMESPACE}} -l db-owner-name=mysql-test-branch-{{.SCENARIO}} --no-headers -o custom-columns=":metadata.name" | head -1)
        BRANCH_ID=$(kubectl get mysqlbranchdatabases -n {{.NAMESPACE}} mysql-test-branch-{{.SCENARIO}} -o jsonpath='{.spec.id}' 2>/dev/null)
        
        if [ -z "$POD" ] || [ -z "$BRANCH_ID" ]; then
          echo "Branch not found or not ready"
          exit 1
        fi
        
        echo "  Pod: $POD"
        echo "  Branch ID: $BRANCH_ID"
        
        # Query the branch database (database name is 'user', not the branch ID)
        kubectl exec -n {{.NAMESPACE}} "$POD" -- mysql -uroot -p{{.MYSQL_ROOT_PASSWORD}} user -e "
          SELECT 'users' as table_name, COUNT(*) as count FROM users
          UNION ALL
          SELECT 'orders', COUNT(*) FROM orders;
        " 2>/dev/null || echo "Failed to query branch database"

  query:source:
    desc: "Query source database"
    vars:
      QUERY: '{{.QUERY | default "SELECT * FROM users"}}'
    cmds:
      - task: _query-source
        vars: {QUERY: "{{.QUERY}}"}
  
  query:branch:
    desc: "Query a branch database"
    vars:
      SCENARIO: '{{.SCENARIO | default "env-val"}}'
      QUERY: '{{.QUERY | default "SELECT * FROM users"}}'
    cmds:
      - task: _query-branch
        vars: {SCENARIO: "{{.SCENARIO}}", QUERY: "{{.QUERY}}"}

  verify:mysql:branches:
    desc: "Quick verification of MySQL branch databases"
    cmds:
      - echo "=== MySQL Source Database ==="
      - kubectl exec -n {{.NAMESPACE}} mysql-test -- mysql -uroot -p{{.SOURCE_DB_PASSWORD}} user -e "SELECT 'users' as tbl, COUNT(*) as cnt FROM users UNION SELECT 'orders', COUNT(*) FROM orders;"
      - echo ""
      - echo "=== MySQL Branches ==="
      - |
        for SCENARIO in env-val secret-ref; do
          POD=$(kubectl get pods -n {{.NAMESPACE}} -l db-owner-name=mysql-test-branch-$SCENARIO -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
          if [ -n "$POD" ]; then
            echo "Branch{{":"}} $SCENARIO"
            kubectl exec -n {{.NAMESPACE}} "$POD" -- mysql -uroot -p{{.MYSQL_ROOT_PASSWORD}} user -e "SELECT 'users' as tbl, COUNT(*) as cnt FROM users UNION SELECT 'orders', COUNT(*) FROM orders;"
            echo ""
          fi
        done

  verify:mariadb:branches:
    desc: "Quick verification of MariaDB branch databases"
    cmds:
      - echo "=== MariaDB Source Database ==="
      - kubectl exec -n {{.NAMESPACE}} mariadb-test -- mysql -uroot -p{{.SOURCE_DB_PASSWORD}} user -e "SELECT 'users' as tbl, COUNT(*) as cnt FROM users UNION SELECT 'orders', COUNT(*) FROM orders;"
      - echo ""
      - echo "=== MariaDB Branches ==="
      - |
        for SCENARIO in env-val secret-ref; do
          POD=$(kubectl get pods -n {{.NAMESPACE}} -l db-owner-name=mariadb-test-branch-$SCENARIO -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
          if [ -n "$POD" ]; then
            echo "Branch{{":"}} $SCENARIO"
            kubectl exec -n {{.NAMESPACE}} "$POD" -- mysql -uroot -p{{.MYSQL_ROOT_PASSWORD}} user -e "SELECT 'users' as tbl, COUNT(*) as cnt FROM users UNION SELECT 'orders', COUNT(*) FROM orders;"
            echo ""
          fi
        done

  clean:modular:
    desc: "Delete all modular test resources"
    cmds:
      - echo "Cleaning up MySQL modular tests..."
      - kubectl delete -k {{.MODULAR_TESTS_DIR}} --ignore-not-found=true
      - kubectl delete namespace {{.NAMESPACE}} --ignore-not-found=true --wait=false
      - echo "Cleanup complete"
  
  clean:branches:
    desc: "Delete only branch databases (keep source)"
    cmds:
      - echo "Cleaning branch databases..."
      - kubectl delete mysqlbranchdatabase --all -n {{.NAMESPACE}} --ignore-not-found=true
      - echo "Branch databases cleaned"
  
  refresh:
    desc: "Refresh MySQL data (clean and redeploy without cluster rebuild)"
    cmds:
      - echo "Refreshing MySQL test data..."
      - task: clean
      - |
        echo "Waiting for namespace to be fully deleted..."
        for i in {1..60}; do
          if ! kubectl get namespace {{.NAMESPACE}} >/dev/null 2>&1; then
            echo "Namespace deleted"
            break
          fi
          echo "  Waiting for namespace deletion... ($i/60)"
          sleep 2
        done
      - task: deploy:all
      - echo "MySQL data refreshed"

  status:
    desc: "Show status of all MySQL resources"
    cmds:
      - echo ""
      - echo "=== Source Database ==="
      - kubectl get pod mysql-test -n {{.NAMESPACE}} -o wide 2>/dev/null || echo "Not deployed"
      - echo ""
      - echo "=== Test Scenarios ==="
      - kubectl get pods -n {{.NAMESPACE}} -l test-scenario --show-labels 2>/dev/null || echo "No scenarios deployed"
      - echo ""
      - echo "=== Branch Databases ==="
      - kubectl get mysqlbranchdatabases -n {{.NAMESPACE}} 2>/dev/null || echo "No branches"
      - echo ""
      - echo "=== Branch Database Pods ==="
      - kubectl get pods -n {{.NAMESPACE}} | grep "mysql-branch-db-pod" || echo "No branch pods"
      - echo ""
  
  branches:
    desc: "Show branch database status"
    cmds:
      - echo "=== MySQL Branch Databases ==="
      - kubectl get mysqlbranchdatabases -n {{.NAMESPACE}} -o custom-columns=NAME:.metadata.name,BRANCH_ID:.spec.id,PHASE:.status.phase,EXPIRES:.status.expireTime 2>/dev/null || echo "No branches found"
      - echo ""
      - echo "=== Branch Database Pods ==="
      - kubectl get pods -n {{.NAMESPACE}} --no-headers | grep "mirrord-mysql-branch-db-pod" | awk '{print $1}' || echo "No branch pods found"
      - echo ""
  
  describe:scenario:
    desc: "Describe a test scenario pod"
    vars:
      SCENARIO: '{{.SCENARIO}}'
    cmds:
      - |
        POD=$(kubectl get pods -n {{.NAMESPACE}} -l test-scenario={{.SCENARIO}} --no-headers -o custom-columns=":metadata.name" | head -1)
        kubectl describe pod -n {{.NAMESPACE}} $POD

  _patch-operator:
    internal: true
    desc: "Patch operator with MySQL env vars"
    cmds:
      - kubectl patch deployment mirrord-operator -n mirrord --patch-file {{.ROOT_DIR}}/k8s/overlays/mysql/operator-patch.yaml --type=strategic || true
      - kubectl rollout status deployment/mirrord-operator -n mirrord --timeout=300s || true
  
  _wait-source-db:
    internal: true
    desc: "Wait for source database to be ready"
    cmds:
      - echo "Waiting for source database pod..."
      - kubectl wait --for=condition=ready pod -l app=mysql-test -n {{.NAMESPACE}} --timeout=300s || true
      - |
        echo "Waiting for MySQL to accept connections..."
        for i in {1..30}; do
          if kubectl exec -n {{.NAMESPACE}} mysql-test -- mysql -uroot -p{{.SOURCE_DB_PASSWORD}} -e "SELECT 1" >/dev/null 2>&1; then
            echo "MySQL is ready"
            exit 0
          fi
          echo "  Waiting for MySQL... ($i/30)"
          sleep 2
        done
        echo "✗ MySQL failed to become ready"
        exit 1
  
  _wait-for-databases:
    internal: true
    desc: "Wait for branch databases to be created"
    cmds:
      - echo "Waiting for branch databases to be created (this may take 1-2 minutes)..."
      - sleep 10
      - kubectl wait --for=condition=ready pod -l db-owner-name=mysql-test-branch-env-val -n {{.NAMESPACE}} --timeout=300s || echo "   Branch env-val still initializing..."
      - kubectl wait --for=condition=ready pod -l db-owner-name=mysql-test-branch-secret-ref -n {{.NAMESPACE}} --timeout=300s || echo "   Branch secret-ref still initializing..."
      - sleep 5
      - echo "Branch databases ready"
  
  _query-source:
    internal: true
    vars:
      QUERY: '{{.QUERY}}'
    cmds:
      - kubectl exec -n {{.NAMESPACE}} mysql-test -- mysql -uroot -p{{.SOURCE_DB_PASSWORD}} user -e "{{.QUERY}}"
  
  _query-branch:
    internal: true
    vars:
      SCENARIO: '{{.SCENARIO}}'
      QUERY: '{{.QUERY}}'
    cmds:
      - |
        POD=$(kubectl get pods -n {{.NAMESPACE}} -l db-owner-name=mysql-test-branch-{{.SCENARIO}} --no-headers -o custom-columns=":metadata.name" | head -1)
        if [ -n "$POD" ]; then
          kubectl exec -n {{.NAMESPACE}} "$POD" -- mysql -uroot -p{{.MYSQL_ROOT_PASSWORD}} user -e "{{.QUERY}}"
        else
          echo "Branch '{{.SCENARIO}}' not found or not ready"
          exit 1
        fi

  run:app:local:
    desc: "Run MySQL app locally with mirrord (creates branch DB)"
    dir: '{{.ROOT_DIR}}/apps/mysql-app'
    vars:
      MIRRORD_CONFIG: '{{.MIRRORD_CONFIG | default (print .ROOT_DIR "/k8s/overlays/mysql/mirrord.json")}}'
    cmds:
      - go build -o /tmp/mysql-app main.go
      - '{{.MIRRORD_BIN}} exec -f {{.MIRRORD_CONFIG}} -- /tmp/mysql-app'

  test:mysql:complete:
    desc: "Run MySQL complete test (single YAML file)"
    cmds:
      - task: _patch-operator
      - echo "Deploying MySQL complete test..."
      - kubectl create namespace {{.NAMESPACE}} --dry-run=client -o yaml | kubectl apply -f -
      - kubectl apply -f {{.MYSQL_COMPLETE_FILE}}
      - task: _wait-db
        vars: {DB_TYPE: mysql, POD_NAME: mysql-test}
      - task: _wait-branches
        vars: {DB_TYPE: mysql, BRANCH1: mysql-test-branch-env-val, BRANCH2: mysql-test-branch-secret-ref}

  test:mysql:complete:clean:
    desc: "MySQL complete test from clean cluster (delete + create cluster + test + verify)"
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: test:mysql:complete
      - task: verify:mysql:branches

  test:mariadb:complete:
    desc: "Run MariaDB complete test (MySQL-compatible, single YAML file)"
    cmds:
      - task: _patch-operator
      - echo "Deploying MariaDB complete test..."
      - kubectl create namespace {{.NAMESPACE}} --dry-run=client -o yaml | kubectl apply -f -
      - kubectl apply -f {{.MARIADB_COMPLETE_FILE}}
      - task: _wait-db
        vars: {DB_TYPE: mariadb, POD_NAME: mariadb-test}
      - task: _wait-branches
        vars: {DB_TYPE: mariadb, BRANCH1: mariadb-test-branch-env-val, BRANCH2: mariadb-test-branch-secret-ref}

  test:mariadb:complete:clean:
    desc: "MariaDB complete test from clean cluster (delete + create cluster + test + verify)"
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: test:mariadb:complete
      - task: verify:mariadb:branches

  clean:mysql:complete:
    desc: "Clean up MySQL complete test"
    cmds:
      - echo "Cleaning up MySQL complete test..."
      - kubectl delete -f {{.MYSQL_COMPLETE_FILE}} --ignore-not-found=true
      - echo "Cleanup complete"

  clean:mariadb:complete:
    desc: "Clean up MariaDB complete test"
    cmds:
      - echo "Cleaning up MariaDB complete test..."
      - kubectl delete -f {{.MARIADB_COMPLETE_FILE}} --ignore-not-found=true
      - echo "Cleanup complete"

  _wait-db:
    internal: true
    vars:
      DB_TYPE: '{{.DB_TYPE}}'
      POD_NAME: '{{.POD_NAME}}'
    cmds:
      - echo "Waiting for {{.DB_TYPE}} to be ready..."
      - kubectl wait --for=condition=ready pod/{{.POD_NAME}} -n {{.NAMESPACE}} --timeout=300s
      - |
        echo "Waiting for {{.DB_TYPE}} to accept connections..."
        for i in {1..30}; do
          if kubectl exec -n {{.NAMESPACE}} {{.POD_NAME}} -- mysql -uroot -p{{.SOURCE_DB_PASSWORD}} -e "SELECT 1" >/dev/null 2>&1; then
            echo "{{.DB_TYPE}} is ready"
            break
          fi
          echo "  Waiting for {{.DB_TYPE}}... ($i/30)"
          sleep 2
        done

  _wait-branches:
    internal: true
    vars:
      DB_TYPE: '{{.DB_TYPE}}'
      BRANCH1: '{{.BRANCH1}}'
      BRANCH2: '{{.BRANCH2}}'
    cmds:
      - echo "Waiting for branch databases to be created and ready..."
      - sleep 5
      - |
        echo "Checking branch database status..."
        for i in {1..30}; do
          BRANCH_COUNT=$(kubectl get mysqlbranchdatabases -n {{.NAMESPACE}} --no-headers 2>/dev/null | wc -l | tr -d ' ')
          if [ "$BRANCH_COUNT" -ge 2 ]; then
            echo "Found $BRANCH_COUNT branch databases"
            break
          fi
          echo "  Waiting for branch databases... ($i/30, found $BRANCH_COUNT)"
          sleep 2
        done
      - echo "Waiting for branch databases to reach Ready status..."
      - kubectl wait --for=jsonpath='{.status.phase}'=Ready mysqlbranchdatabase/{{.BRANCH1}} -n {{.NAMESPACE}} --timeout=180s || echo "  Branch env-val not ready yet"
      - kubectl wait --for=jsonpath='{.status.phase}'=Ready mysqlbranchdatabase/{{.BRANCH2}} -n {{.NAMESPACE}} --timeout=180s || echo "  Branch secret-ref not ready yet"
      - echo ""
      - kubectl get mysqlbranchdatabases -n {{.NAMESPACE}}
      - echo ""
      - kubectl get pods -n {{.NAMESPACE}} | grep branch || echo "No branch pods yet"
      - echo ""
      - echo "{{.DB_TYPE}} test deployed. Use 'task mysql:branches' to check status"
