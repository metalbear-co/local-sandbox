version: '3'

vars:
  ROOT_DIR:
    sh: cd .. && pwd
  NAMESPACE: '{{.NAMESPACE | default "test-mirrord"}}'
  MODULAR_TESTS_DIR: '{{.ROOT_DIR}}/k8s/postgres/modular-tests'
  COMPLETE_TESTS_DIR: '{{.ROOT_DIR}}/k8s/postgres/complete-tests'
  POSTGRES_COMPLETE_FILE: '{{.COMPLETE_TESTS_DIR}}/postgres-test.yaml'
  POSTGRES_DIR: '{{.ROOT_DIR}}/k8s/postgres'
  
  MIRRORD_BIN: '{{.MIRRORD_BIN | default "mirrord"}}'

tasks:
  test:
    desc: "Run PostgreSQL modular test (default test)"
    cmds:
      - task: test:modular

  deploy:
    desc: "Deploy PostgreSQL test environment (default to modular)"
    cmds:
      - task: deploy:modular

  verify:
    desc: "Verify PostgreSQL test results (default verification)"
    cmds:
      - task: verify:all

  test:modular:
    desc: "Run PostgreSQL modular test (component-based structure)"
    cmds:
      - task: deploy:modular
      - task: verify:all


  deploy:modular:base:
    desc: "Deploy PostgreSQL modular base resources"
    cmds:
      - echo "Deploying source database..."
      - kubectl create namespace {{.NAMESPACE}} --dry-run=client -o yaml | kubectl apply -f -

  deploy:modular:
    desc: "Deploy PostgreSQL modular test environment"
    cmds:
      - task: deploy:modular:base
      - kubectl apply -k {{.POSTGRES_DIR}}
      - echo "Waiting for source database to be ready..."
      - kubectl wait --for=condition=ready pod -l app=postgres-test -n {{.NAMESPACE}} --timeout=120s
      - echo "Deploying test scenarios..."
      - kubectl apply -k {{.MODULAR_TESTS_DIR}}/scenarios/env-val
      - kubectl apply -k {{.MODULAR_TESTS_DIR}}/scenarios/secret-ref
      - kubectl apply -k {{.MODULAR_TESTS_DIR}}/scenarios/echo
      - echo "Waiting for branch databases to be ready..."
      - sleep 5
      - kubectl wait --for=jsonpath='{.status.phase}'=Ready pgbranchdatabase/pg-test-branch-env-val -n {{.NAMESPACE}} --timeout=180s || true
      - kubectl wait --for=jsonpath='{.status.phase}'=Ready pgbranchdatabase/pg-test-branch-secret-ref -n {{.NAMESPACE}} --timeout=180s || true
      - echo "Waiting for app to be ready..."
      - kubectl wait --for=condition=ready pod -l app=postgres-app -n {{.NAMESPACE}} --timeout=120s || true

  test:complete:
    desc: "Run PostgreSQL complete test (single YAML file)"
    cmds:
      - echo "Deploying PostgreSQL complete test..."
      - kubectl create namespace {{.NAMESPACE}} --dry-run=client -o yaml | kubectl apply -f -
      - kubectl apply -f {{.POSTGRES_COMPLETE_FILE}}
      - echo "Waiting for source database to be ready..."
      - kubectl wait --for=condition=ready pod/postgres-test -n {{.NAMESPACE}} --timeout=120s
      - echo "Waiting for branch databases to be created and ready..."
      - sleep 5
      - kubectl wait --for=jsonpath='{.status.phase}'=Ready pgbranchdatabase/pg-test-branch-env-val -n {{.NAMESPACE}} --timeout=180s || echo "  Branch env-val not ready yet"
      - kubectl wait --for=jsonpath='{.status.phase}'=Ready pgbranchdatabase/pg-test-branch-secret-ref -n {{.NAMESPACE}} --timeout=180s || echo "  Branch secret-ref not ready yet"
      - echo ""
      - kubectl get pgbranchdatabases -n {{.NAMESPACE}}
      - echo ""
      - kubectl get pods -n {{.NAMESPACE}} | grep -E "(postgres-test|pg-)" || echo "No pods yet"
      - echo ""
      - echo "PostgreSQL test deployed. Use 'task postgres:branches' to check status"

  test:complete:verify:
    desc: "Run PostgreSQL complete test and verify branches"
    cmds:
      - task: test:complete
      - task: verify:branches

  clean:complete:
    desc: "Clean up PostgreSQL complete test"
    cmds:
      - echo "Cleaning up PostgreSQL complete test..."
      - kubectl delete -f {{.POSTGRES_COMPLETE_FILE}} --ignore-not-found=true
      - echo "Cleanup complete"

  clean:modular:
    desc: "Delete all PostgreSQL modular test resources"
    cmds:
      - kubectl delete namespace {{.NAMESPACE}} --ignore-not-found=true
      - echo "Waiting for namespace deletion..."
      - |
        while kubectl get namespace {{.NAMESPACE}} 2>/dev/null; do
          echo "Waiting for namespace {{.NAMESPACE}} to be deleted..."
          sleep 2
        done
      - echo "Namespace {{.NAMESPACE}} deleted"

  verify:all:
    desc: "Verify all PostgreSQL test results"
    cmds:
      - echo ""
      - task: verify:source
      - echo ""
      - task: verify:scenario
        vars: {SCENARIO: env-val, EXPECTED_USERS: "5", EXPECTED_ORDERS: "5", EXPECTED_PRODUCTS: "4", MODE: "full copy"}
      - echo ""
      - task: verify:scenario
        vars: {SCENARIO: secret-ref, EXPECTED_USERS: "3", EXPECTED_ORDERS: "4", EXPECTED_PRODUCTS: "0", MODE: "filtered (age >= 18)"}
      - echo ""
      - echo "Tip - Run 'task postgres:branches' to see branch status"
      - echo ""

  verify:source:
    desc: "Verify source database"
    cmds:
      - echo "Source Database (postgres-test)"
      - |
        kubectl exec -n {{.NAMESPACE}} postgres-test -- psql -U postgres -d source_db -c \
        "SELECT 'users' as tbl, COUNT(*) as cnt FROM users UNION SELECT 'orders', COUNT(*) FROM orders UNION SELECT 'products', COUNT(*) FROM products;"

  verify:scenario:
    desc: "Verify a specific test scenario"
    internal: true
    vars:
      SCENARIO: '{{.SCENARIO}}'
      MODE: '{{.MODE | default ""}}'
      EXPECTED_USERS: '{{.EXPECTED_USERS | default "?"}}'
      EXPECTED_ORDERS: '{{.EXPECTED_ORDERS | default "?"}}'
      EXPECTED_PRODUCTS: '{{.EXPECTED_PRODUCTS | default "?"}}'
    cmds:
      - |
        echo "Scenario {{.SCENARIO}} ({{.MODE}})"
        echo "Getting branch pod name..."
        POD=$(kubectl get pod -n {{.NAMESPACE}} -l db-owner-name=pg-test-branch-{{.SCENARIO}} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD" ]; then
          echo "ERROR - No branch pod found for scenario {{.SCENARIO}}"
          exit 1
        fi
        echo "Branch Pod $POD"
        echo "Querying branch database..."
        kubectl exec -n {{.NAMESPACE}} $POD -- psql -U postgres -d branch_db -c \
        "SELECT 'users' as tbl, COUNT(*) as cnt FROM users UNION SELECT 'orders', COUNT(*) FROM orders UNION SELECT 'products', COUNT(*) FROM products ORDER BY tbl;" 2>/dev/null || echo "Query failed"
        echo "Expected - users={{.EXPECTED_USERS}}, orders={{.EXPECTED_ORDERS}}, products={{.EXPECTED_PRODUCTS}}"

  branches:
    desc: "Show all PostgreSQL branch databases"
    cmds:
      - kubectl get pgbranchdatabase -n {{.NAMESPACE}} -o custom-columns=NAME:.metadata.name,PHASE:.status.phase,COPY_MODE:.spec.copy.mode,AGE:.metadata.creationTimestamp

  logs:pod:
    desc: "Show logs for a specific branch pod (ex: task postgres:logs:pod SCENARIO='env-val')"
    vars:
      SCENARIO: '{{.SCENARIO | default "env-val"}}'
    cmds:
      - |
        POD=$(kubectl get pod -n {{.NAMESPACE}} -l db-owner-name={{.SCENARIO}} -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD" ]; then
          echo "ERROR - No branch pod found for scenario {{.SCENARIO}}"
          exit 1
        fi
        kubectl logs -n {{.NAMESPACE}} $POD

  logs:job:
    desc: "Show logs for the init job of a specific scenario (ex: task postgres:logs:job SCENARIO='secret-ref')"
    vars:
      SCENARIO: '{{.SCENARIO | default "env-val"}}'
    cmds:
      - |
        JOB=$(kubectl get job -n {{.NAMESPACE}} -l db-owner-name={{.SCENARIO}} -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$JOB" ]; then
          echo "ERROR - No init job found for scenario {{.SCENARIO}}"
          exit 1
        fi
        echo "Init Job $JOB"
        kubectl logs -n {{.NAMESPACE}} job/$JOB

  logs:app:
    desc: "Show logs for the postgres app"
    cmds:
      - kubectl logs -n {{.NAMESPACE}} -l app=postgres-app --tail=50

  shell:source:
    desc: "Open psql shell to source database"
    cmds:
      - kubectl exec -it -n {{.NAMESPACE}} postgres-test -- psql -U postgres -d source_db

  shell:branch:
    desc: "Open psql shell to a branch database (ex: task postgres:shell:branch SCENARIO='env-val')"
    vars:
      SCENARIO: '{{.SCENARIO | default "env-val"}}'
    cmds:
      - |
        POD=$(kubectl get pod -n {{.NAMESPACE}} -l db-owner-name=pg-test-branch-{{.SCENARIO}} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD" ]; then
          echo "ERROR - No branch pod found for scenario {{.SCENARIO}}"
          exit 1
        fi
        echo "Connecting to branch pod $POD"
        kubectl exec -it -n {{.NAMESPACE}} $POD -- psql -U postgres -d branch_db

  shell:app:
    desc: "Open shell to postgres app"
    cmds:
      - |
        POD=$(kubectl get pod -n {{.NAMESPACE}} -l app=postgres-app -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD" ]; then
          echo "ERROR - No postgres-app pod found"
          exit 1
        fi
        kubectl exec -it -n {{.NAMESPACE}} $POD -- sh

  query:source:
    desc: "Query source PostgreSQL database (ex: task postgres:query:source QUERY='SELECT * FROM users')"
    vars:
      QUERY: '{{.QUERY | default "SELECT * FROM users;"}}'
    cmds:
      - kubectl exec -n {{.NAMESPACE}} postgres-test -- psql -U postgres -d source_db -c "{{.QUERY}}"

  query:branch:
    desc: "Query a branch PostgreSQL database (ex: task postgres:query:branch SCENARIO='env-val' QUERY='SELECT * FROM orders')"
    vars:
      SCENARIO: '{{.SCENARIO | default "env-val"}}'
      QUERY: '{{.QUERY | default "SELECT * FROM users;"}}'
    cmds:
      - |
        POD=$(kubectl get pod -n {{.NAMESPACE}} -l db-owner-name=pg-test-branch-{{.SCENARIO}} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD" ]; then
          echo "ERROR - No branch pod found for scenario {{.SCENARIO}}"
          exit 1
        fi
        kubectl exec -n {{.NAMESPACE}} $POD -- psql -U postgres -d branch_db -c "{{.QUERY}}"

  verify:branches:
    desc: "Quick verification of all branch databases"
    cmds:
      - echo "=== Source Database ==="
      - task: query:source
        vars: {QUERY: "SELECT 'users' as table_name, COUNT(*) as count FROM users UNION SELECT 'orders', COUNT(*) FROM orders UNION SELECT 'products', COUNT(*) FROM products;"}
      - echo ""
      - echo "=== Branch env-val (should have ALL data) ==="
      - task: query:branch
        vars: {SCENARIO: env-val, QUERY: "SELECT 'users' as table_name, COUNT(*) as count FROM users UNION SELECT 'orders', COUNT(*) FROM orders UNION SELECT 'products', COUNT(*) FROM products;"}
      - echo ""
      - echo "=== Branch secret-ref (should have FILTERED data - age>18, amount>50) ==="
      - task: query:branch
        vars: {SCENARIO: secret-ref, QUERY: "SELECT 'users' as table_name, COUNT(*) as count FROM users UNION SELECT 'orders', COUNT(*) FROM orders UNION SELECT 'products', COUNT(*) FROM products;"}


  run:local:
    desc: "Run PostgreSQL app locally with mirrord (creates branch DB with db_branches config)"
    dir: '{{.ROOT_DIR}}/apps/postgres-app'
    vars:
      MIRRORD_CONFIG: '{{.MIRRORD_CONFIG | default (print .ROOT_DIR "/k8s/overlays/postgres/mirrord.json")}}'
    preconditions:
      - sh: test -f {{.MIRRORD_CONFIG}}
        msg: "Config file not found at {{.MIRRORD_CONFIG}}"
    cmds:
      - echo "Building PostgreSQL app..."
      - go build -o /tmp/postgres-app main.go
      - echo "Running with mirrord - config {{.MIRRORD_CONFIG}}"
      - echo "This will create a branch database defined in the config's db_branches section"
      - '{{.MIRRORD_BIN}} exec -f {{.MIRRORD_CONFIG}} -- /tmp/postgres-app'

  test:mirrord:config:
    desc: "Test PostgreSQL with mirrord.json db_branches configuration"
    cmds:
      - echo "Testing PostgreSQL branch creation via mirrord.json..."
      - task: deploy:modular:base
      - echo "Deploying source database..."
      - kubectl apply -f {{.POSTGRES_DIR}}/simple-app/postgres-deployment.yaml
      - echo "Waiting for source database..."
      - kubectl wait --for=condition=ready pod -l app=postgres-test -n {{.NAMESPACE}} --timeout=120s
      - echo ""
      - echo "Now run 'task postgres:run:local' in another terminal to test mirrord with db_branches"
      - echo "The mirrord config is at k8s/overlays/postgres/mirrord.json"
      - echo ""
