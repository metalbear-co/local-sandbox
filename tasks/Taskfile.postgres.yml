version: '3'

vars:
  ROOT_DIR:
    sh: cd .. && pwd
  NAMESPACE: '{{.NAMESPACE | default "test-mirrord"}}'
  TESTS_DIR: '{{.ROOT_DIR}}/k8s/postgres/tests'
  POSTGRES_DIR: '{{.ROOT_DIR}}/k8s/postgres'

tasks:
  test:
    desc: "Run PostgreSQL branching tests"
    cmds:
      - task: deploy
      - task: verify:all


  deploy:base:
    desc: "Deploy PostgreSQL test environment"
    cmds:
      - echo "Deploying source database..."
      - kubectl create namespace {{.NAMESPACE}} --dry-run=client -o yaml | kubectl apply -f -

  deploy:
    desc: "Deploy PostgreSQL test environment"
    cmds:
      - task: deploy:base
      - kubectl apply -k {{.POSTGRES_DIR}}
      - echo "Waiting for source database to be ready..."
      - kubectl wait --for=condition=ready pod -l app=postgres-test -n {{.NAMESPACE}} --timeout=120s
      - echo "Deploying test scenarios..."
      - kubectl apply -k {{.TESTS_DIR}}/scenarios/env-val
      - kubectl apply -k {{.TESTS_DIR}}/scenarios/secret-ref
      - kubectl apply -k {{.TESTS_DIR}}/scenarios/echo
      - echo "Waiting for branch databases to be ready..."
      - sleep 5
      - kubectl wait --for=jsonpath='{.status.phase}'=Ready pgbranchdatabase/pg-test-branch-env-val -n {{.NAMESPACE}} --timeout=180s || true
      - kubectl wait --for=jsonpath='{.status.phase}'=Ready pgbranchdatabase/pg-test-branch-secret-ref -n {{.NAMESPACE}} --timeout=180s || true
      - echo "Waiting for app to be ready..."
      - kubectl wait --for=condition=ready pod -l app=postgres-app -n {{.NAMESPACE}} --timeout=120s || true

  verify:all:
    desc: "Verify all PostgreSQL test results"
    cmds:
      - echo ""
      - task: verify:source
      - echo ""
      - task: verify:scenario
        vars: {SCENARIO: env-val, EXPECTED_USERS: "5", EXPECTED_ORDERS: "5", EXPECTED_PRODUCTS: "4", MODE: "full copy"}
      - echo ""
      - task: verify:scenario
        vars: {SCENARIO: secret-ref, EXPECTED_USERS: "3", EXPECTED_ORDERS: "4", EXPECTED_PRODUCTS: "0", MODE: "filtered (age >= 18)"}
      - echo ""
      - echo "Tip - Run 'task postgres:branches' to see branch status"
      - echo ""

  verify:source:
    desc: "Verify source database"
    cmds:
      - echo "Source Database (postgres-test)"
      - |
        kubectl exec -n {{.NAMESPACE}} postgres-test -- psql -U postgres -d source_db -c \
        "SELECT 'users' as tbl, COUNT(*) as cnt FROM users UNION SELECT 'orders', COUNT(*) FROM orders UNION SELECT 'products', COUNT(*) FROM products;"

  verify:scenario:
    desc: "Verify a specific test scenario"
    internal: true
    vars:
      SCENARIO: '{{.SCENARIO}}'
      MODE: '{{.MODE | default ""}}'
      EXPECTED_USERS: '{{.EXPECTED_USERS | default "?"}}'
      EXPECTED_ORDERS: '{{.EXPECTED_ORDERS | default "?"}}'
      EXPECTED_PRODUCTS: '{{.EXPECTED_PRODUCTS | default "?"}}'
    cmds:
      - |
        echo "Scenario: {{.SCENARIO}} ({{.MODE}})"
        echo "Getting branch pod name..."
        POD=$(kubectl get pod -n {{.NAMESPACE}} -l db-owner-name=pg-test-branch-{{.SCENARIO}} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD" ]; then
          echo "ERROR: No branch pod found for scenario {{.SCENARIO}}"
          exit 1
        fi
        echo "Branch Pod: $POD"
        echo "Querying branch database..."
        kubectl exec -n {{.NAMESPACE}} $POD -- psql -U postgres -d branch_db -c \
        "SELECT 'users' as tbl, COUNT(*) as cnt FROM users UNION SELECT 'orders', COUNT(*) FROM orders UNION SELECT 'products', COUNT(*) FROM products ORDER BY tbl;" 2>/dev/null || echo "Query failed"
        echo "Expected: users={{.EXPECTED_USERS}}, orders={{.EXPECTED_ORDERS}}, products={{.EXPECTED_PRODUCTS}}"

  branches:
    desc: "Show all PostgreSQL branch databases"
    cmds:
      - kubectl get pgbranchdatabase -n {{.NAMESPACE}} -o custom-columns=NAME:.metadata.name,PHASE:.status.phase,COPY_MODE:.spec.copy.mode,AGE:.metadata.creationTimestamp

  logs:pod:
    desc: "Show logs for a specific branch pod"
    vars:
      SCENARIO: '{{.SCENARIO | default "env-val"}}'
    cmds:
      - |
        POD=$(kubectl get pod -n {{.NAMESPACE}} -l db-owner-name={{.SCENARIO}} -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD" ]; then
          echo "ERROR: No branch pod found for scenario {{.SCENARIO}}"
          exit 1
        fi
        kubectl logs -n {{.NAMESPACE}} $POD

  logs:job:
    desc: "Show logs for the init job of a specific scenario"
    vars:
      SCENARIO: '{{.SCENARIO | default "env-val"}}'
    cmds:
      - |
        JOB=$(kubectl get job -n {{.NAMESPACE}} -l db-owner-name={{.SCENARIO}} -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$JOB" ]; then
          echo "ERROR: No init job found for scenario {{.SCENARIO}}"
          exit 1
        fi
        echo "Init Job: $JOB"
        kubectl logs -n {{.NAMESPACE}} job/$JOB

  logs:app:
    desc: "Show logs for the postgres app"
    cmds:
      - kubectl logs -n {{.NAMESPACE}} -l app=postgres-app --tail=50

  shell:source:
    desc: "Open psql shell to source database"
    cmds:
      - kubectl exec -it -n {{.NAMESPACE}} postgres-test -- psql -U postgres -d source_db

  shell:branch:
    desc: "Open psql shell to a branch database"
    vars:
      SCENARIO: '{{.SCENARIO | default "env-val"}}'
    cmds:
      - |
        POD=$(kubectl get pod -n {{.NAMESPACE}} -l db-owner-name=pg-test-branch-{{.SCENARIO}} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD" ]; then
          echo "ERROR: No branch pod found for scenario {{.SCENARIO}}"
          exit 1
        fi
        echo "Connecting to branch pod: $POD"
        kubectl exec -it -n {{.NAMESPACE}} $POD -- psql -U postgres -d branch_db

  shell:app:
    desc: "Open shell to postgres app"
    cmds:
      - |
        POD=$(kubectl get pod -n {{.NAMESPACE}} -l app=postgres-app -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD" ]; then
          echo "ERROR: No postgres-app pod found"
          exit 1
        fi
        kubectl exec -it -n {{.NAMESPACE}} $POD -- sh

  clean:
    desc: "Delete all PostgreSQL test resources"
    cmds:
      - kubectl delete namespace {{.NAMESPACE}} --ignore-not-found=true
      - echo "Waiting for namespace deletion..."
      - |
        while kubectl get namespace {{.NAMESPACE}} 2>/dev/null; do
          echo "Waiting for namespace {{.NAMESPACE}} to be deleted..."
          sleep 2
        done
      - echo "Namespace {{.NAMESPACE}} deleted"
