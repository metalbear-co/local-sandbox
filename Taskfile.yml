version: '3'

dotenv: ['.env']

includes:
  sqs:
    taskfile: ./tasks/Taskfile.sqs.yml
    dir: ./tasks
  mysql:
    taskfile: ./tasks/Taskfile.mysql.yml
    dir: ./tasks
  kafka:
    taskfile: ./tasks/Taskfile.kafka.yml
    dir: ./tasks

vars:
  ROOT_DIR:
    sh: pwd
  OPERATOR_DIR: '{{.ROOT_DIR}}/../operator'
  CHARTS_DIR: '{{.ROOT_DIR}}/../charts/mirrord-operator'
  SCRIPTS_DIR: '{{.ROOT_DIR}}/scripts'
  MIRRORD_DIR: '{{.ROOT_DIR}}/../mirrord'
  OPERATOR_IMAGE: mirrord-operator:custom
  CHART_VERSION:
    sh: grep "appVersion:" {{.CHARTS_DIR}}/Chart.yaml | awk '{print $2}' | tr -d '"'
  NAMESPACE: test-mirrord
  CLUSTER_NAME: '{{.CLUSTER_NAME | default "bearkube"}}' # Set CLUSTER_NAME env var to use a custom cluster

tasks:
  # License management
  license:generate:
    desc: Generate new operator license
    dir: '{{.SCRIPTS_DIR}}'
    cmds:
      - ./generate-license.sh
      - echo "License generated at {{.SCRIPTS_DIR}}/company-license.pem"

  license:create-secret:
    desc: Create license secret in cluster
    vars:
      LICENSE_FILE: '{{.LICENSE_FILE | default .SCRIPTS_DIR}}/company-license.pem'
    preconditions:
      - sh: test -f {{.LICENSE_FILE}}
        msg: "License file not found at {{.LICENSE_FILE}}. Run 'task license:generate' first"
    cmds:
      - kubectl create namespace mirrord --dry-run=client -o yaml | kubectl apply -f -
      - kubectl create secret generic mirrord-operator-license-pem --from-file=license.pem={{.LICENSE_FILE}} -n mirrord --dry-run=client -o yaml | kubectl apply -f -
      - echo "License secret created/updated"

  # Build images
  build:operator:
    desc: Build operator with custom tag
    dir: '{{.OPERATOR_DIR}}'
    cmds:
      - docker build . -f Dockerfile -t {{.OPERATOR_IMAGE}} --build-arg OPERATOR_LICENSE_ISSUER_PUBLIC_KEY="$(cat {{.SCRIPTS_DIR}}/license-issuer.pem) --no-cache"
      - task: operator:tag-and-load
      - echo "Operator built and tagged as mirrord-operator:{{.CHART_VERSION}}"

  operator:tag-and-load:
    desc: Tag and load existing operator image into minikube
    cmds:
      - docker tag {{.OPERATOR_IMAGE}} mirrord-operator:{{.CHART_VERSION}}
      - echo "Removing old image from minikube to ensure fresh load..."
      - minikube -p {{.CLUSTER_NAME}} ssh "docker rmi mirrord-operator:{{.CHART_VERSION}} --force" || true
      - echo "Loading fresh operator image into minikube..."
      - minikube -p {{.CLUSTER_NAME}} image load mirrord-operator:{{.CHART_VERSION}}
      - echo "Verifying image is loaded..."
      - minikube -p {{.CLUSTER_NAME}} ssh "docker images mirrord-operator:{{.CHART_VERSION}}"

  build:app:sqs:
    desc: Build SQS consumer app
    dir: '{{.ROOT_DIR}}/apps/sqs-consumer'
    cmds:
      - docker build -t sqs-consumer:local .
      - minikube -p {{.CLUSTER_NAME}} image load sqs-consumer:local

  build:app:kafka:
    desc: Build Kafka consumer app
    dir: '{{.ROOT_DIR}}/apps/kafka-consumer'
    cmds:
      - docker build -t kafka-consumer:local .
      - minikube -p {{.CLUSTER_NAME}} image load kafka-consumer:local

  build:app:mysql:
    desc: Build MySQL app
    dir: '{{.ROOT_DIR}}/apps/mysql-app'
    cmds:
      - docker build -t mysql-app:local .
      - minikube -p {{.CLUSTER_NAME}} image load mysql-app:local

  build:app:
    desc: Build all consumer apps
    cmds:
      - task: build:app:sqs
      - task: build:app:kafka
      - task: build:app:mysql

  build:
    desc: Build all images
    cmds:
      - task: build:operator
      - task: build:app

  # Cluster management
  cluster:create:
    desc: Create fresh minikube cluster with infrastructure
    cmds:
      - minikube -p {{.CLUSTER_NAME}} start --driver=docker
      - minikube -p {{.CLUSTER_NAME}} addons enable metrics-server
      - kubectl config use-context {{.CLUSTER_NAME}}
      - task: infra:all
      - echo "Cluster {{.CLUSTER_NAME}} ready with infrastructure"

  cluster:delete:
    desc: Delete minikube cluster
    cmds:
      - minikube -p {{.CLUSTER_NAME}} delete

  # Infrastructure setup
  infra:argo-rollouts:
    desc: Install Argo Rollouts CRD and controller
    cmds:
      - kubectl create namespace argo-rollouts --dry-run=client -o yaml | kubectl apply -f -
      - kubectl apply -n argo-rollouts -f https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml
      - kubectl wait --for=condition=available deployment/argo-rollouts -n argo-rollouts --timeout=300s
      - echo "Argo Rollouts installed successfully"

  infra:argocd:
    desc: Install ArgoCD (optional for GitOps)
    cmds:
      - kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
      - kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
      - kubectl wait --for=condition=available deployment/argocd-server -n argocd --timeout=300s
      - echo "ArgoCD installed successfully"

  infra:all:
    desc: Install all infrastructure dependencies
    cmds:
      - task: infra:argo-rollouts
      - echo "Infrastructure ready"

  infra:status:
    desc: Check infrastructure component status
    cmds:
      - echo "=== Infrastructure Status ==="
      - |
        echo -n "Argo Rollouts: "
        kubectl get deployment argo-rollouts -n argo-rollouts >/dev/null 2>&1 && echo "Installed" || echo "✗ Not installed"
      - |
        echo -n "ArgoCD: "
        kubectl get deployment argocd-server -n argocd >/dev/null 2>&1 && echo "Installed" || echo "✗ Not installed"
      - |
        echo -n "LocalStack: "
        kubectl get deployment localstack -n localstack >/dev/null 2>&1 && echo "Running" || echo "✗ Not running"
      - |
        echo -n "Operator: "
        kubectl get deployment mirrord-operator -n mirrord >/dev/null 2>&1 && echo "Running" || echo "✗ Not running"

  # Operator installation
  operator:install:
    desc: Install operator with custom image (idempotent)
    deps: [infra:all, build:operator, license:create-secret]
    cmds:
      - helm upgrade --install mirrord-operator {{.CHARTS_DIR}} --namespace mirrord -f {{.ROOT_DIR}}/operator-values.yaml
      - kubectl wait --for=condition=ready pod -l app=mirrord-operator -n mirrord --timeout=300s

  operator:install-nobuild:
    desc: Install operator without building (reuse existing image)
    deps: [infra:all, license:create-secret]
    cmds:
      - task: operator:tag-and-load
      - helm upgrade --install mirrord-operator {{.CHARTS_DIR}} --namespace mirrord -f {{.ROOT_DIR}}/operator-values.yaml
      - kubectl wait --for=condition=ready pod -l app=mirrord-operator -n mirrord --timeout=300s

  operator:install-with-new-license:
    desc: Generate new license and install operator
    cmds:
      - task: license:generate
      - task: operator:install

  operator:uninstall:
    desc: Uninstall operator
    cmds:
      - helm uninstall mirrord-operator -n mirrord || true
      - kubectl delete namespace mirrord --ignore-not-found=true

  operator:update:
    desc: Quick update - rebuild operator and upgrade in cluster (no cluster deletion)
    cmds:
      - task: build:operator
      - helm upgrade --install mirrord-operator {{.CHARTS_DIR}} --namespace mirrord -f {{.ROOT_DIR}}/operator-values.yaml
      - echo "Force deleting old operator pods to ensure fresh image is used..."
      - kubectl delete pods -n mirrord -l app=mirrord-operator --force --grace-period=0 2>/dev/null || true
      - echo "Waiting for new operator pod to be ready..."
      - kubectl wait --for=condition=ready pod -l app=mirrord-operator -n mirrord --timeout=300s
      - echo "Operator updated successfully"

  # Internal test runner
  _run-test:
    internal: true
    vars:
      OVERLAY: '{{.OVERLAY}}'
      PATCH_FILE: '{{.PATCH_FILE}}'
      WAIT_SELECTOR: '{{.WAIT_SELECTOR}}'
      WAIT_NAMESPACE: '{{.WAIT_NAMESPACE | default .NAMESPACE}}'
      CONSUMER_APP: '{{.CONSUMER_APP | default "sqs-consumer"}}'
    cmds:
      - kubectl kustomize {{.ROOT_DIR}}/k8s/overlays/{{.OVERLAY}} | kubectl apply -f -
      - kubectl patch deployment mirrord-operator -n mirrord --patch-file {{.ROOT_DIR}}/k8s/overlays/{{.PATCH_FILE}}/operator-patch.yaml --type=strategic || true
      - kubectl rollout status deployment/mirrord-operator -n mirrord --timeout=300s || true
      - kubectl wait --for=condition=ready pod -l {{.WAIT_SELECTOR}} -n {{.WAIT_NAMESPACE}} --timeout=300s || true
      - kubectl wait --for=condition=ready pod -l app={{.CONSUMER_APP}} -n {{.NAMESPACE}} --timeout=300s || true
      - kubectl get pods -n {{.NAMESPACE}}
      - kubectl get mirrordworkloadqueueregistries -n {{.NAMESPACE}} || true

  # Test scenarios
  test:sqs:
    desc: Run SQS LocalStack test
    deps: [build:app:sqs, operator:install]
    cmds:
      - task: _run-test
        vars:
          OVERLAY: sqs-localstack
          PATCH_FILE: sqs-localstack
          WAIT_SELECTOR: app.kubernetes.io/name=localstack
          WAIT_NAMESPACE: localstack

  test:sqs:clean:
    desc: Delete cluster and run SQS test fresh
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: test:sqs

  test:sqs:clean-nobuild:
    desc: Delete cluster and run SQS test (skip operator build)
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: build:app:sqs
      - task: license:create-secret
      - task: operator:install-nobuild
      - task: _run-test
        vars:
          OVERLAY: sqs-localstack
          PATCH_FILE: sqs-localstack
          WAIT_SELECTOR: app.kubernetes.io/name=localstack
          WAIT_NAMESPACE: localstack

  test:sqs-sa:
    desc: Run SQS test with service account
    deps: [build:app:sqs, operator:install]
    cmds:
      - task: _run-test
        vars:
          OVERLAY: sqs-localstack-with-sa
          PATCH_FILE: sqs-localstack
          WAIT_SELECTOR: app.kubernetes.io/name=localstack
          WAIT_NAMESPACE: localstack

  test:sqs-sa:clean:
    desc: Delete cluster and run SQS with service account test fresh
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: test:sqs-sa

  test:sqs-sa:clean-nobuild:
    desc: Delete cluster and run SQS with service account test (skip operator build)
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: build:app:sqs
      - task: license:create-secret
      - task: operator:install-nobuild
      - task: _run-test
        vars:
          OVERLAY: sqs-localstack-with-sa
          PATCH_FILE: sqs-localstack
          WAIT_SELECTOR: app.kubernetes.io/name=localstack
          WAIT_NAMESPACE: localstack

  test:mysql:
    desc: Run MySQL test
    deps: [build:app:mysql, operator:install]
    cmds:
      - task: _run-test
        vars:
          OVERLAY: mysql
          PATCH_FILE: mysql
          WAIT_SELECTOR: app=mysql
          WAIT_NAMESPACE: test-mirrord
          CONSUMER_APP: mysql-app
          SKIP_REGISTRY: "true"

  test:mysql:clean:
    desc: Delete cluster and run MySQL test fresh
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: test:mysql

  test:mysql:clean-nobuild:
    desc: Delete cluster and run MySQL test (skip operator build)
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: build:app:mysql
      - task: license:create-secret
      - task: operator:install-nobuild
      - task: _run-test
        vars:
          OVERLAY: mysql
          PATCH_FILE: mysql
          WAIT_SELECTOR: app=mysql
          WAIT_NAMESPACE: test-mirrord
          CONSUMER_APP: mysql-app

  test:mysql-sa:
    desc: Run MySQL test with service account
    deps: [build:app:mysql, operator:install]
    cmds:
      - task: _run-test
        vars:
          OVERLAY: mysql-with-sa
          PATCH_FILE: mysql
          WAIT_SELECTOR: app=mysql
          WAIT_NAMESPACE: test-mirrord
          CONSUMER_APP: mysql-app

  test:mysql-sa:clean-nobuild:
    desc: Delete cluster and run MySQL with service account test (skip operator build)
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: build:app:mysql
      - task: license:create-secret
      - task: operator:install-nobuild
      - task: _run-test
        vars:
          OVERLAY: mysql-with-sa
          PATCH_FILE: mysql
          WAIT_SELECTOR: app=mysql
          WAIT_NAMESPACE: test-mirrord
          CONSUMER_APP: mysql-app
          SKIP_REGISTRY: "true"

  test:kafka:
    desc: Run Kafka test
    deps: [build:app:kafka, operator:install]
    cmds:
      - task: _run-test
        vars:
          OVERLAY: kafka
          PATCH_FILE: kafka
          WAIT_SELECTOR: app=kafka-cluster
          WAIT_NAMESPACE: test-mirrord
          CONSUMER_APP: kafka-consumer

  test:kafka:clean:
    desc: Delete cluster and run Kafka test fresh
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: test:kafka

  test:kafka:clean-nobuild:
    desc: Delete cluster and run Kafka test (skip operator build)
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: build:app:kafka
      - task: license:create-secret
      - task: operator:install-nobuild
      - task: _run-test
        vars:
          OVERLAY: kafka
          PATCH_FILE: kafka
          WAIT_SELECTOR: app=kafka-cluster
          WAIT_NAMESPACE: test-mirrord
          CONSUMER_APP: kafka-consumer

  test:kafka-sa:
    desc: Run Kafka test with service account
    deps: [build:app:kafka, operator:install]
    cmds:
      - task: _run-test
        vars:
          OVERLAY: kafka-with-sa
          PATCH_FILE: kafka
          WAIT_SELECTOR: app=kafka-cluster
          WAIT_NAMESPACE: test-mirrord
          CONSUMER_APP: kafka-consumer

  test:kafka-sa:clean-nobuild:
    desc: Delete cluster and run Kafka with service account test (skip operator build)
    cmds:
      - task: cluster:delete
      - task: cluster:create
      - task: build:app:kafka
      - task: license:create-secret
      - task: operator:install-nobuild
      - task: _run-test
        vars:
          OVERLAY: kafka-with-sa
          PATCH_FILE: kafka
          WAIT_SELECTOR: app=kafka-cluster
          WAIT_NAMESPACE: test-mirrord
          CONSUMER_APP: kafka-consumer

  test:all:clean:
    desc: Run all tests with fresh cluster for each
    cmds:
      - task: test:sqs:clean
      - task: test:sqs-sa:clean
      - task: test:kafka:clean
      - task: test:kafka-sa:clean-nobuild
      - task: test:mysql:clean
      - task: test:mysql-sa:clean-nobuild

  test:all:clean-nobuild:
    desc: Run all tests with fresh cluster for each (skip operator build)
    cmds:
      - task: test:sqs:clean-nobuild
      - task: test:sqs-sa:clean-nobuild
      - task: test:kafka:clean-nobuild
      - task: test:kafka-sa:clean-nobuild
      - task: test:mysql:clean-nobuild
      - task: test:mysql-sa:clean-nobuild

  # Cleanup utilities
  clean:namespaces:
    desc: Delete all test namespaces
    cmds:
      - kubectl delete namespace {{.NAMESPACE}} --ignore-not-found=true
      - kubectl delete namespace localstack --ignore-not-found=true
      - task: operator:uninstall

  # Common logs
  logs:operator:
    desc: Show operator logs
    cmds:
      - kubectl logs -n mirrord deployment/mirrord-operator --tail=100 -f

  # Copy target testing
  test:copy-target:setup:
    desc: Setup environment for copy-target testing
    deps: [build:app:sqs, operator:install]
    cmds:
      - kubectl apply -k {{.ROOT_DIR}}/k8s/overlays/sqs-localstack
      - kubectl wait --for=condition=ready pod -l app=sqs-consumer -n {{.NAMESPACE}} --timeout=120s
      - kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=localstack -n localstack --timeout=120s
      - echo "Environment ready. Run 'task test:copy-target:run' to create copy-target pod"

  test:copy-target:run:
    desc: Create a copy-target pod (foreground, runs 10min)
    cmds:
      - |
        echo "Starting mirrord with copy_target..."
        {{.MIRRORD_BIN | default "mirrord"}} exec -f {{.ROOT_DIR}}/k8s/sqs-localstack/copy-target-config.json -- sleep 10

  test:copy-target:run-long:
    desc: Create a long-running copy-target pod (10 minutes)
    cmds:
      - |
        echo "Starting long-running mirrord copy-target (600s)..."
        {{.MIRRORD_BIN | default "mirrord"}} exec -f {{.ROOT_DIR}}/k8s/sqs-localstack/copy-target-config.json -- sleep 600

  test:copy-target:restart-operator:
    desc: Restart the operator pod
    cmds:
      - kubectl delete pod -n mirrord -l app=mirrord-operator
      - kubectl wait --for=condition=ready pod -n mirrord -l app=mirrord-operator --timeout=120s
      - echo "Operator restarted"

  # Quick test cycle
  dev:
    desc: Quick dev cycle - rebuild and test
    cmds:
      - task: build
      - task: clean:namespaces
      - task: test:sqs

